#include "Display.h"

#include <avr/io.h>
#include <LUFA/Drivers/Peripheral/SPI.h>
#include "../Data/font6x8.h"
#include <string.h>

static uint8_t screenmemory [] = {
	/* LCD Memory organised in 64 horizontal pixel and 6 rows of byte
	 B  B .............B  -----
	 y  y .............y        \
	 t  t .............t         \
	 e  e .............e          \
	 0  1 .............63          \
	                                \
	 D0 D0.............D0            \
	 D1 D1.............D1            / ROW 0
	 D2 D2.............D2           /
	 D3 D3.............D3          /
	 D4 D4.............D4         /
	 D5 D5.............D5        /
	 D6 D6.............D6       /
	 D7 D7.............D7  ----
	*/

	// ROW0, BYTE0 to BYTE63
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// ROW1, BYTE64 to BYTE127
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// ROW2, BYTE128 to BYTE191
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// ROW3, BYTE192 to BYTE255
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// ROW4, BYTE256 to BYTE319
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// ROW5, BYTE320 to BYTE383
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t cursor_row = 0;
static uint8_t cursor_col = 0;

static volatile bool scroll_trig = false;
static uint16_t scroll_counter = 0;
static int16_t scroll_offset = -FONTWIDTH;
static bool scroll_fwd = true;

void Display_MillisecondElapsed(void) {
	if(scroll_counter == 0) {
		scroll_counter = DISPLAY_SCROLL_STEP;
		scroll_trig = true;
	}
	scroll_counter--;
}

void Display_Init(void) {
    DDRB |= _BV(PB4) | _BV(PB5)| _BV(PB6); //DC, Rst and CS as output
    PORTB |= _BV(PB6); //Set CS high

    PORTB |= _BV(PB5); //Take display out of reset

    Display_Command(DISPLAY_OFF_CMD);

    Display_Command(DISPLAY_CLKDIV_CMD);
    Display_Command(0x80);

    Display_Command(DISPLAY_MUXRATIO_CMD);
    Display_Command(0x2F);

    Display_Command(DISPLAY_CHARGEPUMP_CMD);
    Display_Command(0x14);

    Display_Command(DISPLAY_SEGREMAP_CMD | 0x01); // Enable segment remapping
    Display_Command(DISPLAY_COMSCANDEC_CMD); //Scan COM in reverse

    Display_Command(DISPLAY_CONTRAST_CMD);
    Display_Command(0x8F);

    Display_Command(DISPLAY_PRECHG_CMD);
    Display_Command(0xF1);

    Display_Command(DISPLAY_VCOMDESELECT_CMD);
    Display_Command(0x40);

    Display_Command(DISPLAY_ON_CMD);
    Display_Update();
}

void Display_Command(uint8_t data) {
    PORTB &= ~_BV(PB4); //Set DC low for command
    PORTB &= ~_BV(PB6); //Set CS low
    SPI_SendByte(data);
    PORTB |= _BV(PB6); //Set CS high
}

void Display_Data(uint8_t data) {
    PORTB |= _BV(PB4); //Set DC high for data
    PORTB &= ~_BV(PB6); //Set CS low
    SPI_SendByte(data);
    PORTB |= _BV(PB6); //Set CS high
}

void Display_PageAddr(uint8_t addr) {
    Display_Command(0xB0 | (addr & 0x07));
}

void Display_ColAddr(uint8_t addr) {
    Display_Command(0x0f & addr);
    Display_Command((0x10 | (addr>>4))+0x02); // Display shifted right 32px
}

void Display_Update(void) {
    uint8_t page;
    uint8_t col;
    for(page=0;page<DISPLAY_PAGES;page++) {
        Display_PageAddr(page);
        Display_ColAddr(0);
        for(col=0;col<0x40;col++) {
            Display_Data(screenmemory[page*0x40+col]);
        }
    }
}

void Display_Clear(void) {
	memset(screenmemory, 0, sizeof(screenmemory));
}

void Display_SetCursor(uint8_t row, uint8_t col) {
    cursor_row = row;
    cursor_col = col;
}

void Display_Write(const char *str, bool scroll) {
	int16_t skip = 0;
	if(scroll) {
		int16_t slen = strlen(str)*FONTWIDTH;
		// Number of columns the string overflows the display
		int16_t draw_ovf = slen+cursor_col-DISPLAY_COLS;

		if(scroll_trig) {
			scroll_trig = false;
			if(scroll_offset <= -FONTWIDTH) {
				scroll_fwd = true;
			}
			if(scroll_offset >= draw_ovf+FONTWIDTH) {
				scroll_fwd = false;
			}
			if(scroll_fwd) {scroll_offset++;} else {scroll_offset--;}
		}

		if(draw_ovf == 0 || scroll_offset < 0) {
			skip = 0;
		}else if(scroll_offset >= draw_ovf) {
			skip = draw_ovf;
		}else{
			skip = scroll_offset;
		}

	}
	uint8_t x = 0;
    char c = *str;
    while(c != '\0') {
		if(skip>FONTWIDTH) {
			skip-=FONTWIDTH;
		}else{
            for(x=0;x<FONTWIDTH;x++) {
				if(skip>0) {
					skip--;
				} else {
					uint16_t idx = (uint16_t)(c-FONTSTART)*FONTWIDTH;
	                screenmemory[cursor_row*0x40+cursor_col] = pgm_read_byte(font6x8+idx+x);
					cursor_col += 1;
				}
				if(cursor_col == DISPLAY_COLS) return;
            }
		}
        c = *(++str);
    }
}

void Display_WritePos(uint8_t row, uint8_t col, const char *str, bool scroll) {
	Display_SetCursor(row, col);
	Display_Write(str, scroll);
}

void Display_Write_P(const char *str, bool scroll) {
	char *buffer = malloc(strlen_P(str)+1);
	strcpy_P(buffer, str);
	Display_Write(buffer, scroll);
	free(buffer);
}

void Display_WritePos_P(uint8_t row, uint8_t col, const char *str, bool scroll) {
	char *buffer = malloc(strlen_P(str)+1);
	strcpy_P(buffer, str);
	Display_WritePos(row, col, buffer, scroll);
	free(buffer);
}

void Display_ResetScroll(void) {
	scroll_offset = -FONTWIDTH;
	scroll_fwd = true;
}
